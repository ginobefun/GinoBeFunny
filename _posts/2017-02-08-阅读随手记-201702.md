---
title: 阅读随手记 201702
date: 2017-02-08 12:31:23
tags: [微服务, 架构, 消息中间件, 缓存, RPC, 监控, 高性能, 高并发, 高可用]
categories: Reading Record
link_title: reading_record_201702
---
关键字：微服务, 架构, 消息中间件, 缓存, RPC, 监控, 高性能, 高并发, 高可用。
<!-- more -->

###  [Microservices: A definition of this new architectural term](https://martinfowler.com/articles/microservices.html) Martin Fowler

#### 微服务架构风格
- 一组微型的服务/独立开发/通过轻量级机制通信/自动化的独立部署/各服务之间可采用不同语言和技术方案；
- 很难给微服务下一个具体的定义，Martin Fowler通过九大特性来阐述微服务；


> the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.

#### 微服务的九大特性
##### 1. 组件化与服务
- **组件**（component）是一个可以独立更换和升级的软件单元；
- **软件库）**（libraries是能被链接到程序且通过方法调用的组件；
- **服务**（services）是进程外的组件，通过web service或rpc的机制来通信；
- 使用服务而非软件库的方式来组件化的主要原因是服务可被独立部署（避免一个组件修改导致需要重新部署整个应用），另外一个好处是能获得更加显式的组件接口（想想单体应用中的API依赖）；
- 当然也有不足之处，比如远程调用比进程内的调用要更加昂贵；

##### 2. 围绕业务功能组织团队
- 对一个大型的应用进行分解时，通常是按照技术层面来进行划分，比如分为前端开发、后端开发和数据库开发（当然实际情况比这更细），但是这样会带来一个问题就是一个很小的需求都需要跨团队的项目合作和进度安排；这就是**康威定律**（任何设计系统的组织，都会产生这样一个设计，即该设计的结构与该组织的沟通结构相一致）起作用的例子；
- 而微服务是通过**业务功能**将系统分解为若干服务，这些服务针对该业务领域提供多层次广泛的软件实现；因此团队是**跨职能**的，它拥有软件开发所需的全方位的技能（如用户体验、数据库和项目管理）；
- 大型单体应用系统也可以根据业务功能进行模块化设计，但是通常的问题是一个团队会包含太多的功能，而团队之间的边界也不够清晰；

##### 3. 做产品而非做项目
- 大部分的应用开发都使用这样一个产品模型：一旦某项软件功能已交付，就会将软件移交给维护团队，而开发团队随之被解散；
- 而微服务主张**“一个团队应该拥有该产品的整个生命周期”**（原子亚马逊的“you build, you run it”）这样的理念，即一个开发团队对一个生产环境下运行的软件负全责；
- 这样的产品理念是与业务功能相绑定的，它不会把软件开成是一系列待完成功能的集合，而是一种持续提升客户业务功能的关系；
- 当然，单体应用也可以采用上述的产品理念，但是更细粒度的服务能使服务的开发者和它的用户更近；

##### 4. 智能终端和傻瓜管道
- 在不同的进程进行通信时，多数的产品或方法会在其中加入大量的智能特性，有个典型的例子就是ESB（企业服务总线），它通常包括消息路由、编制、转换和业务规则应用；
- 而微服务主张采用另一种做法：**智能终端**（smart endpoints）和**傻瓜管道**（dumb pipes）。这里的理解是应该尽可能地简化进程间的通信，将一些需要智能处理的逻辑（比如路由、重试等）交给服务处理；
- 微服务最常用的两种协议是：带有资源API的HTTP请求-响应协议和轻量级的消息发送协议（如RabbitMQ、ZeroMQ）；
- 将一个单体应用拆分为微服务的最大挑战就是改变原有的通信模式，如果直接将原先的进程内方法调用改为RPC会导致微服务直接产生繁琐的通信，因此应该考虑更粗粒度的方式调用；

##### 5. 去中心化的治理
- 集中治理的一个问题是会趋向于在单一技术平台上制定标准从而带来局限性；
- 微服务中的**分权治理**（去中心化的）使得每个服务可以选择不同的技术，比如选择不同的语言和数据库；
- 相比于选用一组已定义好的标准，微服务的开发者更喜欢自己编写一些有用的工具，这些工具通常源于他们的微服务实施过程并分享给更多的团队；比如Nteflix就是一个很好的例子，这家提供网络视频点播的公司开源了一系列的实施微服务的工具；
- 对微服务社区来说，像[**容错读取**](https://martinfowler.com/bliki/TolerantReader.html)（Tolerant Reader）和[**消费者驱动的契约**](https://martinfowler.com/articles/consumerDrivenContracts.html)（Consumer-Driven Contracts）的模式已经被用于日常管理；
- 像Netflix这样的公司已经开始推行分权治理，这样可以令程序员更加注重质量（谁都不想半夜被电话叫去修复问题对吧），而这些与之前传统的集中治理有着天壤之别；

##### 6. 去中心化的数据管理
- **去中心化的数据管理**从最抽象的层面看，意味着各个系统对客观世界所构建的概念模型将彼此不同，比如客户的概念对于销售和支撑团队就有所不同；
- 思考这类问题的一个有用的方法就是使用**领域驱动设计**（Domain-Driven Design, DDD）中的[**上下文边界**](http://martinfowler.com/bliki/BoundedContext.html)（Bounded Context）的概念；DDD将一个复杂的领域划分为多个上下文边界，并且将它们的相互关系用图表示出来；
- 不同于单体应用喜欢共用一个单独的数据库（也许是被商业数据库的license逼出来的），微服务更喜欢让每一个服务管理其自有的数据库，可以采用相同数据库技术的不同实例，也可以采用完全不同的数据库系统；
- 但是去中心化的数据管理会带来数据一致性的问题，对此微服务强调的是**无事务的协调**（transactionless coordination between services），这源自微服务社区明确地认识到以下两点：即数据一致性可能只要求数据最终一致性，并且一致性问题能够通过补偿操作来进行处理；

##### 7. 基础设施自动化
- 云的发展已经很大程度上降低了构建、部署和运维微服务的复杂性了；
- 许多使用微服务构建的团队都具备**持续交付**（Continuous Delivery）的经验，这样的团队广泛采用了基础设施自动化的技术，如下图的构建流水线所示：

![构建流水线](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/basic_pipeline.png)

- 持续交付需要大量的**自动化测试**以及**自动化部署的能力**，通过这两个关键特点使得我们能更有信心、更愉快地部署功能到生成环境；另外，微服务的独立性也使得部署更加容易（这里的容易是指只需要部署修改的服务而不需要部署整个应用），当然也会带来困难（原来只需要部署一个系统，而现在需要部署更多的服务），此时就需要在部署工具上投入精力改进；

##### 8. 容错设计
- 使用微服务作为组件，需要设计成能容忍这些服务所出现的故障；一旦某个服务出现故障，其他任何对该服务的调用都会出现故障，客户端需要尽可能优雅地处理这种情况；与单体应用相比，这是微服务引入的额外的复杂性；
- Netflix公司开源的[**Simian Army**](https://github.com/Netflix/SimianArmy)能够诱导服务发生故障来测试应用的弹性和监控能力；
- [**断路器**](http://martinfowler.com/bliki/CircuitBreaker.html)（Circuit Breaker）是一种用于隔离故障的模式，Netflix公司的这篇很精彩的[博客](http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html)解释了这些模式是如何应用的；
- **容错设计**要求能够快速地检测出故障，而且在可能的情况下自动恢复服务；此时**实时监控**就变得非常重要，它可用来检查架构元素指标（比如数据库每秒接收到多少请求）和业务相关指标（如系统每分钟收到多少订单）以便预测故障的发生；这对于微服务来说尤为重要，因为微服务对于服务编排和事件协作的偏好更易导致突发行为；
- 采用微服务的团队通常希望使用仪表盘或者日志记录装置来监控服务的运行和各项指标；

##### 9. 演进式设计
- 每当试图将软件系统拆分为各个组件时，都会面对一个棘手的问题，即如何拆分，拆分的原则是什么？
- 一个组件的关键属性，是具有**独立可替换性和可升级性**（independent replacement and upgradeability），这使得我们在重写一个组件时更多的是聚焦于功能而非与不用担心与其他的关联组件；
- 而事实上，许多做微服务的团队会更进一步，他们明确地预期许多服务将来会报废而不是长期演进；比如英国卫报网站，他们依然使用原先的单体应用作为网站核心，而对于一些新的功能，比如增加报道一个体育赛事的页面，就会采用微服务的方式来添加，一旦赛事结束了，这个服务就可以被废除；
- 这种强调可更换性的特点是模块化设计一般性原则的一个特例，通过**变化模式**（the pattern of change）来驱动进行模块化的实现；将那些能在同时发生变化的东西放到相同的模块中，如果发现需要同时反复变更两个服务是，这就是它们两个需要被合并的一个信号；
- 将一个个组件放入一个个服务中增加了做出更精细化版本发布的机会，对于单体应用，任何变化都需要做一次整个应用系统的全量构建和部署，而对微服务来说，只需要部署修改的服务即可；

#### 微服务是未来的方向吗？
- 作者通过该文阐述了微服务的主要思路和原则，在当时已经有一些公司如亚马逊和Netflix提供了正面的经验，收到了不少正面的评价；
- 架构决策所产生的真正效果通常需要若干年后才能真正显现，当时考虑的限制微服务的因素主要有组件拆分的难度、组件直接的复杂关联关系以及团队技能，但从目前的发展来看，已经有越来越多的企业采用了微服务的架构；

### [Netflix Conductor：一个微服务编制引擎](http://www.infoq.com/cn/news/2016/12/netflix-conductor) Abel Avram&杨雷

- Netflix开发了一个叫[Conductor](https://netflix.github.io/conductor/)的编制引擎，已经在内部生产环境中使用了一年了。在这段时间里，Netflix已经运行了大约260万个处理工作流，包括简单的线性工作流，以及运行数天的动态工作流。
- 主要特性：能够构建复杂工作流；能够通过微服务执行任务；使用JSON DSL描述的工作流蓝图；执行过程可见、可跟踪；能够暂停、恢复、重启、停止任务；任务执行通常是异步的，也可以强制同步执行；处理工作流能够扩展到百万级别；
- Conductor的架构图如下所示；其中API和存储层都是可插拔的，允许使用不同的队列和存储引擎；工作流中的任务分为两种类型：Worker（运行在远端机器上的用户任务和System（运行在引擎的JVM上的任务），后者是用来对Worker执行任务进行branch、fork、join；Worker任务通过HTTP或者gRPC和Conductor通信；

![Conductor的架构图](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/conductor-architecture.png)

### [深度学习并不是在“模拟人脑”](https://mp.weixin.qq.com/s?__biz=MzI5NTIxNTg0OA==&mid=2247485059&idx=1&sn=e516921ae4beda15c7ddf5cb4c93bf78) 周志华

- 当**特征信息和样本信息**不充分时，机器学习可能就帮不上忙；
- 用机器学习解决问题更多的时候像一个裁缝，一定要量体裁衣，针对某个问题专门设计有效的方法，这样才能得到一个更好的结果；**按需设计、度身定制**，是在做机器学习应用的时候特别重要的一点；
- 机器学习有着深厚的理论基础，其中最基本的理论模型叫做**概率近似正确模型**；机器学习做的事情，是你给我数据之后，希望能够以很高的概率给出一个好模型；
- 从生物机理来说的话，一个神经元收到很多其它神经元发来的电位信号，信号经过放大到达它这里，如果这个累积信号比它自己的电位高了，那这个神经元就被激活了；其实神经网络本质上，是一个简单函数通过多层嵌套叠加形成的一个数学模型，背后其实是数学和工程在做支撑；而神经生理学起的作用，可以说是给了一点点启发，但是远远不像现在很多人说的神经网络研究受到神经生理学的“指导”，或者是“模拟脑”；
- 深度学习火起来的3个因素：有了大量的训练数据、有很强的计算设备、使用大量的“窍门”（Trick）；

### [Notes for deep learning on NLP](https://medium.com/htc-research-engineering-blog/notes-for-deep-learning-on-nlp-94ddfcb45723#.75qqasvc1) Frank Chung


### [一小时掌握深度学习和TensorFlow](http://mp.weixin.qq.com/s/NII_ZqalRjx9su7d6u4MHw)  谷歌云官方&新智元
原文地址：https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/#0

### [分布式配置管理平台的设计与实现](http://mp.weixin.qq.com/s?__biz=MzIyNjE4NjI2Nw==&mid=2652558155&idx=1&sn=351b10f4ecb80756bc91a25487d482be) 架构文摘

### [一篇好TM长的关于配置中心的文章](http://jm.taobao.org/2016/09/28/an-article-about-config-center/) 坤宇


### [Reddit是如何使用Memcached来存储3TB缓存数据的？](http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&mid=2659598891&idx=1&sn=6ae9c213ce167b3a8295b7d7d4804048)
薛命灯


### [剖析TensorFlow架构与设计：编程模型](http://mp.weixin.qq.com/s?__biz=MzI3MzEzMDI1OQ==&mid=2651816114&idx=1&sn=471a5d0728ab981c0634456d775a0dac) 刘光聪



### [微信高并发资金交易系统设计方案](http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650995437&idx=1&sn=fefff4bff3e183d656a2d242e4c0a382) 方乐明



### [大话分布式系统理论基础(上篇)](http://mp.weixin.qq.com/s/p4PEZPjxJyYXKpkCCdShbw) bangerlee



### [大话分布式系统理论基础(下篇)](http://mp.weixin.qq.com/s/gSfbhCDJbx6FwxzCAXrS6w) bangerlee


### [MySQL大表优化方案](https://segmentfault.com/a/1190000006158186) manong


### [亿级规模的Elasticsearch优化实战](http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=209488723&idx=1&sn=d60c0637d7a9f4a4b981a69f10c6b90a) 王卫华


### [怎样读一本书V5.0](https://ljinkai.github.io/2017/02/08/how-to-read-a-book) ljinkai


### [JVM为什么需要GC？](http://mp.weixin.qq.com/s/KVj5NwYyXyJdaqKIDu-Avg) 周明耀
- HotSpot的垃圾回收器总结：如果你想要最小化地使用内存和并行开销，请选Serial GC；如果你想要最大化应用程序的吞吐量，请选Parallel GC；如果你想要最小化GC的中断或停顿时间，请选CMS GC。
- G1 GC基本思想：G1 GC是一个压缩收集器，它基于回收最大量的垃圾原理进行设计。G1 GC利用递增、并行、独占暂停这些属性，通过拷贝方式完成压缩目标。此外，它也借助并行、多阶段并行标记这些方式来帮助减少标记、重标记、清除暂停的停顿时间，让停顿时间最小化是它的设计目标之一。
- G1 GC的垃圾回收循环组成：年轻代循环、多步骤并行标记循环、混合收集循环、Full GC；
- G1的区间设计：在G1中，堆被平均分成若干个大小相等的区域（Region）。每个Region都有一个关联的Remembered Set（简称RS），RS的数据结构是Hash表，里面的数据是Card Table （堆中每512byte映射在card table 1byte）。简单的说RS里面存在的是Region中存活对象的指针。当Region中数据发生变化时，首先反映到Card Table中的一个或多个Card上，RS通过扫描内部的Card Table得知Region中内存使用情况和存活对象。在使用Region过程中，如果Region被填满了，分配内存的线程会重新选择一个新的Region，空闲Region被组织到一个基于链表的数据结构（LinkedList）里面，这样可以快速找到新的Region。

![G1的区间设计](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/design_of_g1.png)


### [让机器读懂用户--大数据中的用户画像](https://mp.weixin.qq.com/s?__biz=MzI2MzM3MzkyMg==&mid=2247484433&idx=1&sn=f30a6a3585becc1a500772aaa78fd937) 杨杰
- 用户画像（persona）的概念最早由交互设计之父Alan Cooper提出:“Personas are a concrete representation of target users.” 是指真实用户的虚拟代表，是建立在一系列属性数据之上的目标用户模型。随着互联网的发展，现在我们说的用户画像又包含了新的内涵——通常用户画像是根据用户人口学特征、网络浏览内容、网络社交活动和消费行为等信息而抽象出的一个标签化的用户模型。构建用户画像的核心工作，**主要是利用存储在服务器上的海量日志和数据库里的大量数据进行分析和挖掘**，给用户贴“标签”，而“标签”是能表示用户某一维度特征的标识。具体的标签形式可以参考下图某网站给其中一个用户打的标签。

![用户画像例子](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/persona.jpg)

- 用户画像的作用：精准营销、用户研究、个性服务、业务决策；
- 用户画像的内容：对于大部分互联网公司，用户画像都会包含**人口属性和行为特征**。人口属性主要指用户的年龄、性别、所在的省份和城市、教育程度、婚姻情况、生育情况、工作所在的行业和职业等。行为特征主要包含活跃度、忠诚度等指标。另外，电商购物网站的用户画像，一般会提取用户的**网购兴趣和消费能力**等指标。
- 用户画像的生产，大致可以分为以下几步：

![网易用户画像](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/netease_persona.jpg)

> 1. 用户建模，指确定提取的用户特征维度，和需要使用到的数据源。
> 2. 数据收集，通过数据收集工具，如Flume或自己写的脚本程序，把需要使用的数据统一存放到Hadoop集群。
> 3. 数据清理，数据清理的过程通常位于Hadoop集群，也有可能与数据收集同时进行，这一步的主要工作，是把收集到各种来源、杂乱无章的数据进行字段提取，得到关注的目标特征。
> 4. 模型训练，有些特征可能无法直接从数据清理得到，比如用户感兴趣的内容或用户的消费水平，那么可以通过收集到的已知特征进行学习和预测。
> 5. 属性预测，利用训练得到的模型和用户的已知特征，预测用户的未知特征。
> 6. 数据合并，把用户通过各种数据源提取的特征进行合并，并给出一定的可信度。
> 7. 数据分发，对于合并后的结果数据，分发到精准营销、个性化推荐、CRM等各个平台，提供数据支持。

- 应用示例之个性化推荐：很多推荐场景都会用到基于商品的协同过滤，而基于商品协同过滤的核心是一个商品相关性矩阵W，假设有n个商品，那么W就是一个n \* n的矩阵，矩阵的元素wij代表商品Ii和Ij之间的相关系数。而根据用户访问和购买商品的行为特征，可以把用户表示成一个n维的特征向量U=[ i1, i2, ..., in ]。于是U \* W可以看成用户对每个商品的感兴趣程度V=[ v1, v2, ..., vn ]，这里v1即是用户对商品I1的感兴趣程度，v1= i1\*w11 + i2\*w12 + in\*w1n。如果把相关系数w11, w12, ..., w1n 看成要求的变量，那么就可以用LR模型，代入训练集用户的行为向量U，进行求解。这样一个初步的LR模型就训练出来了，效果和基于商品的协同过滤类似。

### [推荐系统本质与网易严选实践](http://mp.weixin.qq.com/s?__biz=MzA4Mzc0NjkwNA==&mid=2650782153&idx=1&sn=d90906f57d45d8991a9be1269627315d)  沈燕

- 推荐系统作用本质：有资料称亚马逊的推荐系统带来的GMV占其全站总量的20%-30%；推荐的本质就是提升用户体验，为此它们最主要的方式就是帮助用户快速的找到它需要的产商品，其他的方式还包括给用户新颖感等。
- 推荐系统工作原理本质：所谓embedding，数学上的意义就是映射。如word2vec通过语料训练把词变成一个数百维的向量，向量的每一维没有明确的物理意义（或者说我们无法理解）。推荐系统如果可以把人很精确地映射成一个向量，把物品也映射成一个同维度同意义的向量，那么推荐就是可以按规则处理的精确的事情了。

![最佳的推荐形式](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/recommendation.png)

- 电商推荐系统的特点：商品种类数巨大，不同的商品需要不同的embedding；单种商品深度不够，难以有效embedding；人对商品的兴趣大都建立在短期或者瞬时需求之上；大量耐消品的影响；用户理论上对所有商品都会有兴趣。基于以上的原因，在电商领域难以找到完美的embedding方式来实现推荐。其实我们在看各大电商的个性化推荐时，无论宣称背后用怎样复杂的模型融合，从结果看，用户近期行为的权重是非常大的，使得结果非常像itemCF推荐出来的。

#### 网易严选推荐实践
网易严选推荐的基础模型采用的是CTR模型，基于LR（逻辑回归）。

![网易严选推荐模型](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/netease_recommendation_1.jpg)


在核心的特征工程方面，网易严选推荐团队将用户的具体属性（性别、收入水平、地域等）、用户在网易严选的行为属性（短期，长期）、及时间上下文（季节、上次购买时间间隔等）作为属性空间，从1层迪卡尔积开始往上构造N层迪卡尔积形成复杂属性空间P，挖掘属性空间与商品的相关，对有明显相关（正相关或负相关）的（属性、物品）对构造特征。

用户属性空间

![用户属性空间](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/netease_recommendation_2.jpg)


具体属性应用

![具体属性应用](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/netease_recommendation_3.jpg)


行为属性作为抽象属性与具体属性置以相同的地位

![行为属性](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/netease_recommendation_4.jpg)

二阶属性（属性的2重迪卡尔积）

![二阶属性](http://oi46mo3on.bkt.clouddn.com/15_reading_201702/netease_recommendation_5.jpg)

从结果来看，这一套特征工程方法可以挖出比较全的特征集，在鲁棒性与效果上都有不错的效果，自上线以来各项指标均在稳步提升。

### [业界难题-“跨库分页”的四种方案](http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959942&idx=1&sn=e9d3fe111b8a1d44335f798bbb6b9eea) 58沈剑


### [基础机器学习算法](http://mp.weixin.qq.com/s/fE612rbYl9TOkHyPzMAsmA) 晓惑










