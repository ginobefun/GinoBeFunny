---
title: 阅读随手记 201704
date: 2017-04-08 13:25:52
tags: [微服务, 架构, Elasticsearch]
categories: Reading Record
link_title: reading_record_201704
---
关键字：微服务, 架构, Elasticsearch。
<!-- more -->

### [Elasticsearch前沿：ES 5.x改进详解与ES6展望](https://mp.weixin.qq.com/s/yVbZfE7oWGmnfmcFTeSV4w)  曾勇

- 如果你的场景是日志，那么基本上数据进去之后是不需要进行修改的，所以现在ES新增了一个append-only的索引模式，也就是当ES是自动生成ID的时候，ES可以跳过不必要的版本检测，**大概可以提升20%左右的索引性能**。
- 在数据结构方面，新增了多个range字段类型，现在你可以计算连续数据的交并集，可以是时间范围，也可以是数值范围。
- 下一个特性值得介绍的就是**_all 字段的移除**，去掉_all字段之后，磁盘占用少了不少，索引性能也有一些提升。
- 现在有一个新的高亮器：Unified Highlighter，大家可能会问，目前ES默认已经提供了3种不同的高亮器，为什么还会有一个新的轮子呢，因为之前的用法有点复杂, 用户选择起来比较困难，新的unified highlighter目的就是简化高亮的使用，可以支持前面3种高亮类型的自动选择。
- 还有一个是keyword类型可以通过normalizer来进行标准化了，keyword类型相比text类型就是不能分词，但是可能同样需要进行相应的标准化处理，比如统一转成小写，移除标点符号等等，使用方式和analyzer一样。
- 另一个就是Multi-Word Synonyms，之前是不支持同义词中间有空格分割的，分词的时候会帮你切分开，搜索的时候不能正确处理词组这种同义词。
- 同义词现在可以支持词组了，也就是说同义词如果是由多个词组成的，不会在分词的时候被傻傻的拆开，而是正确的处理。
- 还一个就是字段折叠（ Field collapsing），这个特性比较有意思，你可以在搜索的时候，按某个字段作为维度进行去重，我这里写过一篇详细的博客，有兴趣的可以去看看：http://elasticsearch.cn/article/132
- ES的搜索，对于一些耗时较长的查询，现在可以通过ES的任务管理机制来进行取消了，感兴趣的可以查看文档：https://www.elastic.co/guide/en/elasticsearch/reference/5.3/search.html#global-search-cancellation
- 现在term aggs提供了一种分区的概念，你可以对一个字段，分n次进行聚合，分而治之，有兴趣的可以看看文档：https://www.elastic.co/guide/en/elasticsearch/reference/5.3/search-aggregations-bucket-terms-aggregation.html#_filtering_values_with_partitions
- 当你的集群变红的时候，新增的 /_cluster/allocation/explain 接口能够直接告诉你哪里出了问题；
- Java REST Client也有了更新，ES之前提供了一个偏底层的Java HTTP REST client，但是用起来太费劲，需要手动拼 JSON，现在Java REST Client分成了Java High Level REST Client和Java Low Level REST Client， High Level基于Low Level来实现，顾名思义，提供更多用户方便的接口调用，High Level REST Client将提供和Transport Client类似的接口，不用手动去拼接QueryDSL的JSON了，目测在 5.5 版本提供。
- 以前的搜索的reduce操作都是要等到把每个分片的结果都拿到本地之后再做合并，现在新增的batched search reduce phases提供了分批进行reduce的行为，也就是不用全部拿到之后再做reduce，而是拿到足够的分配（默认512）之后就开始做reduce，然后拿到合并结果，释放相关的资源。
- ES 6.0展望：稀疏性Doc Values的支持；Index sorting，即在索引阶段的排序，即我们查询的时候有时候会根据某个字段的值进行排序，比如时间、编号等等；顺序号的支持，每个es的操作都有一个顺序编号，这个属于es内部的一个功能，可以提供快速的分片副本恢复或同步、跨数据中心的节点恢复、甚至提供一个Changes API 等；无缝滚动升级，使之能够从5的最后一个版本滚动升级到6的最后一个版本，不需要集群的完整重启。


### [Elasticsearch 5.x 字段折叠的使用](http://elasticsearch.cn/article/132) medcl

- 什么是字段折叠，可以理解就是按特定字段进行合并去重，比如我们有一个菜谱搜索，我希望按菜谱的“菜系”字段进行折叠，即返回结果每个菜系都返回一个结果，也就是按菜系去重，我搜索关键字“鱼”，要去返回的结果里面各种菜系都有，有湘菜，有粤菜，有中餐，有西餐，别全是湘菜，就是这个意思，通过按特定字段折叠之后，来丰富搜索结果的多样性。
- 有人肯定会想到，使用term agg+ top hits agg来实现啊，这种组合两种聚和的方式可以实现上面的功能，不过也有一些局限性，比如，不能分页、结果不够精确以及数据量大的情况下聚合比较慢。
- 而新的的字段折叠的方式是怎么实现的的呢，有这些要点：折叠+取inner_hits分两阶段执行，所以top hits永远是精确的；字段折叠只在top hits层执行，不需要每次都在完整的结果集上对为每个折叠主键计算实际的doc values值，和term agg 相比要节省很多内存；因为只在top hits上进行折叠，所以相比组合聚合的方式，速度要快很多；折叠top docs不需要使用全局序列来转换string，相比agg这也节省了很多内存；分页成为可能，和常规搜索一样，具有相同的局限，先获取from+size的内容，再合并；search_after和scroll暂未实现，不过具备可行性；折叠只影响搜索结果，不影响聚合，搜索结果的total是所有的命中纪录数，去重的结果数未知（无法计算）。
- 来个例子：


    PUT recipes
    POST recipes/type/_mapping
    {
      "properties": {
        "name":{
          "type": "text"
        },
        "rating":{
          "type": "float"
        },"type":{
          "type": "keyword"
        }
      }
    }
    
    
    POST recipes/type/
    {
      "name":"清蒸鱼头","rating":1,"type":"湘菜"
    }
    POST recipes/type/
    {
      "name":"剁椒鱼头","rating":2,"type":"湘菜"
    }
    POST recipes/type/
    {
      "name":"红烧鲫鱼","rating":3,"type":"湘菜"
    }
    POST recipes/type/
    {
      "name":"鲫鱼汤（辣）","rating":3,"type":"湘菜"
    }
    POST recipes/type/
    {
      "name":"鲫鱼汤（微辣）","rating":4,"type":"湘菜"
    }
    POST recipes/type/
    {
      "name":"鲫鱼汤（变态辣）","rating":5,"type":"湘菜"
    }
    POST recipes/type/
    {
      "name":"广式鲫鱼汤","rating":5,"type":"粤菜"
    }
    POST recipes/type/
    {
      "name":"鱼香肉丝","rating":2,"type":"川菜"
    }
    POST recipes/type/
    {
      "name":"奶油鲍鱼汤","rating":2,"type":"西菜"
    } 

    GET recipes/type/_search
    {
      "query": {
        "match": {
          "name": "鱼"
        }
      },
      "collapse": {
        "field": "type",
        "inner_hits": {
          "name": "top_rated",
          "size": 2,
          "sort": [
            {
              "rating": "desc"
            }
          ]
        }
      },
      "sort": [
        {
          "rating": {
            "order": "desc"
          }
        }
      ],
      "size": 2,
      "from": 0
    }


### [如何做出搜索和推荐深度融合的兴趣引擎架构](https://mp.weixin.qq.com/s/7DOj5Hed3Q4Crr8ng4TeBw) 田明军

搜索/推荐工作流程

![搜索/推荐工作流程](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/search_recom_flow.png)

一点资讯搜索/推荐架构

![一点资讯搜索/推荐架构](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/search_recom_structure.png)


### [携程实时用户行为系统实践](https://mp.weixin.qq.com/s/OJdlpP62YWGmVnBWsfpVZw)  陈清渠

携程实时用户行为系统架构

![携程实时用户行为系统架构](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/Logic_View.png)

- 数据有两种流向，分别是处理流和输出流。
- 在处理流，行为日志会从客户端（App/Online/H5）上传到服务端的Collector Service。Collector Service将消息发送到分布式队列。数据处理模块由流计算框架完成，从分布式队列读出数据，处理之后把数据写入数据层，由分布式缓存和数据库集群组成。
- 输出流相对简单，web service的后台会从数据层拉取数据，并输出给调用方，有的是内部服务调用，比如推荐系统，也有的是输出到前台，比如浏览历史。
- 系统实现采用的是Java+Kafka+Storm+Redis+Mysql+Tomcat+Spring的技术栈。
- 实时性：首先是用storm解决突发流量洪峰的问题，通过storm处理框架，消息能在进入kafka之后毫秒级别被处理；此外storm具有强大的scale out能力，只要通过后台修改worker数量参数，并重启topology，可以马上扩展计算能力，方便应对突发的流量洪峰；实时用户行为系统采用的at least once的策略，这种策略下消息可能会重发，所以程序处理实现了幂等支持；
- 实时行为双队列设计：在部分情况下数据处理需要重试，但是无法连接一般需要更长时间等待网络或数据库的恢复，这种情况下处理程序不能一直等待，否则会造成数据延迟。实时用户行为系统采用了双队列的设计来解决这个问题。

![实时行为双队列设计](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/double_queue.png)

- 可用性：首先是系统层面上做了全栈集群化，另外系统在部分模块不可用时通过降级处理保障整个系统的可用性。


### [Spark技术在京东智能供应链预测的应用](https://mp.weixin.qq.com/s/FK4rjuWyI6S6IZ4pAdMc4g) 杨冬越 郭景瞻

- 背景：京东的仓库按功能划分为RDC（区域分发中心，中心城市）、FDC（区域运转中心，中小城市及边远地区）、大件中心仓、大件卫星仓、图书仓和城市仓等。京东首先从供货商采购商品到RDC，再根据实际需求调配到FDC，再运往离客户最近的配送站，由快递员送到客户手中。借助机器学习、大数据等技术，技术在很多供应链优化问题上都已经实现系统化，实现全流程自动化，在这其中预测技术起着至关重要的底层支撑作用。
- 预测系统：主要支持三大业务：销量预测、单量预测和GMV预测。其中销量预测主要支持商品补货、商品调拨；单量预测主要支持仓库、站点的运营管理；GMV预测主要支持销售部门计划的定制。

![预测系统](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/forecasting_system.png)

- 预测系统架构：先从外部数据源获取我们所需的业务数据，然后对基础数据进行加工清洗，再通过时间序列、机器学习等人工智能技术对数据进行处理分析，最后计算出预测结果并通过多种途径推送给下游系统使用。

![预测系统架构](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/forecasting_system_structure.png)

- 预测系统核心：基础层（HDFS用来做数据存储，Yarn用来做资源调度，BDP用来做任务调度）、框架层（以Spark RDD、Spark SQL、Hive为主）、工具层（比较常用的包有xgboost、numpy、pandas、sklearn、scipy和hyperopt等）、算法层（时间序列、机器学习和结合业务开发的一些独有的算法）；

![预测系统核心](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/forecasting_system_core.png)

- 以机器学习算法为主的流程如下：

![以机器学习算法为主的流程](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/forecasting_ml_flow.png)

1. 特征构建：通过数据分析、模型试验确定主要特征，通过一系列任务生成标准格式的特征数据。
2. 模型选择：不同的商品有不同的特性，所以首先会根据商品的销量高低、新品旧品、假节日敏感性等因素分配不同的算法模型。
3. 特征选择：对一批特征进行筛选过滤不需要的特征，不同类型的商品特征不同。
4. 样本分区：对训练数据进行分组，分成多组样本，真正训练时针对每组样本生成一个模型文件。一般是同类型商品被分成一组，比如按品类维度分组，这样做是考虑并行化以及模型的准确性。
5. 模型参数：选择最优的模型参数，合适的参数将提高模型的准确度，因为需要对不同的参数组合分别进行模型训练和预测，所以这一步是非常耗费资源。
6. 模型训练：待特征、模型、样本都确定好后就可以进行模型训练，训练往往会耗费很长时间，训练后会生成模型文件，存储在HDFS中。
7. 模型预测：读取模型文件进行预测执行。
8. 多模型择优：为了提高预测准确度，我们可能会使用多个算法模型，当每个模型的预测结果输出后系统会通过一些规则来选择一个最优的预测结果。
9. 预测值异常拦截：我们发现越是复杂且不易解释的算法越容易出现极个别预测值异常偏高的情况，这种预测偏高无法结合历史数据进行解释，因此我们会通过一些规则将这些异常值拦截下来，并且用一个更加保守的数值代替。
10. 模型评价：计算预测准确度，我们通常用使用mapd来作为评价指标。
11. 误差分析：通过分析预测准确度得出一个误差在不同维度上的分布，以便给算法优化提供参考依据。


### [对CQRS的基础理解](https://mp.weixin.qq.com/s/S2UGCS00gWzr-nuAapR96g) 张逸

- CQRS即Command Query Responsibility Seperation（命令查询职责分离），其设计思想来源于Mayer提出的CQS（Command Query Seperation）。这种命令与查询的分离方式，可以更好地控制请求者的操作。查询操作不会造成数据的修改，因而它属于一种幂等操作，可以反复地发起，而不用担心会对系统造成影响。基于这种特性，我们还可以为其提供缓存，从而改进查询的性能。命令操作则与之相反，它会直接影响系统信息的改变。
- 查询操作与命令操作对事务的要求也不一样。由于查询操作不会改变系统状态，因而，不会产生最终的数据不一致。从请求响应的角度来看，查询操作常常需要同步请求，实时返回结果；命令操作则不然，因为我们并不期待命令操作必须返回结果，这就可以采用fire-and-forget方式，而这种方式正是运用异步操作的前提。此外，对于大多数软件系统而言，查询操作发起的频率通常要远远高于命令操作。如上种种，都是将命令与查询进行分离的根本原因。
- 下图是CQRS框架AxonFramework官方文档给出的CQRS架构图。在这个架构图中，最核心的概念是Command、Event。以我的理解，CQRS模式的风格源头就是基于事件的异步状态机模型。抛开命令查询分离这一核心原则，这才是CQRS的基础内容。

![CQRS架构图](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/cqrs-arch.png)

- CQRS对设计者的影响，是将领域逻辑，尤其是业务流程，皆看做是一种领域对象状态迁移的过程。这一点与REST将HTTP应用协议看做是应用状态迁移的引擎，有着异曲同工之妙。这种观点（或设计视图）引出了Command与Event的概念。Command是系统中会引起状态变化的活动，通常是一种命令语气，例如注册会议RegisterToConference。至于Event，则描述了某种事件的发生，通常是命令的结果（但并不一定是直接结果，但源头一定是因为发送了命令），例如OrderConfirmed。


### [我对CQRS/EventSourcing架构的思考](https://mp.weixin.qq.com/s/uZPzDopFApOHTXzwEbfluQ) 汤雪华

- **聚合**，它通过定义对象之间清晰的所属关系和边界来实现领域模型的内聚，并避免了错综复杂的难以维护的对象关系网的形成。聚合定义了一组具有内聚关系的相关对象的集合，我们把聚合看作是一个修改数据的最小原子单元。

![聚示意图](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/DDD_Aggregation_Example.png)

- **聚合根**：每个聚合都有一个根对象，根对象管理聚合内的其他子对象（实体、值对象），聚合之间的交互都是通过聚合根来交互，不能绕过聚合根去直接和聚合下的子实体进行交互。
- **Eventual Consistency**：聚合内的数据修改，是ACID强一致性的；跨聚合的数据修改，是最终一致性的。遵守这个原则，可以让我们最大化的降低并发冲突，从而最大化的提高整个系统的吞吐。
- **In Memory**：指整个系统中的所有的聚合根对象都活在内存。在In-Memory的架构下，当要修改某个聚合根的状态时，它已经在内存，我们可以直接拿到该对象的引用，且框架会尽量保证聚合根对象的状态就是最新的。聚合根是在内存中的最小计算单元，每个聚合内部都封装了业务规则，并保证数据的强一致性。
- **Event Sourcing**：不保存对象的最新状态，而是保存对象产生的所有事件；通过事件溯源得到对象最新状态。
- **Event Sourcing VS CRUD**：对于CRUD，DB的记录可变，可以增删改；对于ES，没有更新、删除，只有Append Event，不可变。
- **Actor Model**：其核心思想是对象直接不会直接调用来通信，而是通过发消息来通信。每个Actor都有一个Mailbox，它收到的所有的消息都会先放入Mailbox中，然后Actor内部单线程处理Mailbox中的消息。从而保证对同一个Actor的任何消息的处理，都是线性的，无并发冲突。从全局上来看，就是整个系统中，有很多的Actor，每个Actor都在处理自己Mailbox中的消息，Actor之间通过发消息来通信。Akka框架就是实现Actor模型的并行开发框架，并且Akka框架融入了聚合、In-Memory、Event Sourcing这些概念。Actor非常适合作为DDD聚合根。Actor的状态修改是由事件驱动的，事件被持久化起来，然后通过Event Sourcing的技术，还原特定Actor的最新状态到内存。

![Actor Model](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/Actor_Model.jpg)

- 下图是**CQRS架构的典型架构图**。CQRS架构的核心出发点是将整个系统的架构分割为读和写两部分，从而方便我们对读写两端进行分开优化；CQRS架构的一致性模型为最终一致性。采用CQRS架构的一个前提是，你的系统要接受系统使用者查询到的数据可能不是最新的，而是有几个毫秒的延迟。

![CQRS架构](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/CQRS_ES_Arch.jpg)

- **CQRS架构的适用场景**：当我们的应用的写模型和读模型差别比较大时；当我们希望实践DDD时，因为CQRS架构可以让我们实现领域模型不受任何ORM框架带来的对象和数据库的阻抗失衡的影响；当我们希望对系统的查询性能和写入性能分开进行优化时，尤其是读/写比非常高的系统，CQ分离是必须的；当我们希望我们的系统同时满足高并发的写、高并发的读的时候；因为CQRS架构可以做到C端最大化的写，Q端非常方便的提供可扩展的读模型。
- **C端的命令执行流程**：发送命令到分布式MQ；然后命令的订阅者处理命令；订阅者内部根据不同的命令调用不同的Command Handler进行处理；Command Handler内部根据命令所指定的聚合根ID从In-Memory内存中直接获取聚合根对象的引用，然后操作聚合根对象；聚合根对象状态发生变化并产生事件；框架负责自动持久化事件到Event Storage；框架负责将事件发布到Event MQ；Event订阅者订阅事件，然后调用对应的Event Handler进行处理，如更新Data Storage；
- **Q端的查询执行流程**：调用轻薄的Query Service，传如Query DTO；Query Service从读库进行查询并返回结果；
- 挖掘出**更多有用的特性**：一个命令只允许修改一个聚合根；命令或事件在分布式MQ的路由根据聚合根ID来路由，也就是同一个聚合根的命令和事件都在一个队列里；引入Command Mailbox，Event Mailbox这两个概念，将聚合根需要处理的命令和产生的事件都队列化去并发，做到架构上最大的并行，将并发降低到最低；引入Group Commit技术，做到整个C端的架构层面支持批量提交聚合根产生的事件，从而极大的提高C端的整体吞吐量；通过引入Saga的概念，做到基于事件驱动的最终一致性；
- **Event Sourcing的优点**：记录了数据完整变化过程，最详细的日志；可以将系统还原到任何一个时间点的状态；Domain Event非常有业务价值，BI分析事件能预测业务未来发展情况；可以有效解决线上的数据问题，线下重演一遍，就能知道哪里出问题；不再需要用到ORM，所以没有O/R阻抗失衡的问题，领域模型的设计可以更OO；将Command、Event串联起来，可以分析聚合根的整个变化过程，有助于排查分析问题；自动并发冲突检测、命令的幂等处理；
- **Event Sourcing的缺点**：事件数量巨大，如何存储；如果单个聚合根事件过多，则重演会造成性能问题；领域模型重构被制约，事件的修改必须兼容以前的结构；数据库订正不在有效；架构实践门槛高，没有成熟框架支撑基本无望；需要具备DDD领域建模的能力；事件驱动状态的修改，思维转变难。


### [北大AI公开课第6讲 王俊：DNA是生命数字化的过程，AI改变生命科学](https://mp.weixin.qq.com/s/h7IhHK1vfrHQYDpFLVZ7yA) 新智元

视频回放链接：http://www.iqiyi.com/l_19rrfgal1z.html

### [北大AI公开课第7讲 徐伟：AGI 2050年前实现可能性超50%](https://mp.weixin.qq.com/s/mBfXDpqabIFdksCYTixcaw) 机器学习研究会 

视频回放链接：http://www.iqiyi.com/l_19rrbkb3az.html

### [北大AI公开课第8讲 李航：自然语言处理——理想与现实、机遇与挑战](https://mp.weixin.qq.com/s/Kxu_4QUdWQrjue9W1TvfDg)  机器学习研究会

课程回放链接：http://www.iqiyi.com/w_19rtxrunb9.html


### [机器学习演化史，方法、应用场景与发展趋势](https://mp.weixin.qq.com/s/B4RV1iO9fciguqP9J1hCxQ)  新智元

#### 机器学习演化史：各学派发展融合，最终让自动机器成为可能

![机器学习演化史](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_evolution.png)

- 符号学派（Symbolists）是使用基于规则的符号系统做推理的人。这种方法主要的缺陷在于其脆弱性，因为在边缘情况下，一个僵化的知识库似乎总是不适用，但在现实中存在这种模糊性和不确定性是不可避免的。爱用方法：**规则和决策树**；
- 贝叶斯学派（Bayesians）是使用概率规则及其依赖关系进行推理的一派。这种方法与符号学方法的相似之处在于可以以某种方式得到对结果的解释，另一个优点是存在可以在结果中表示的不确定性的量度。爱用方法：**朴素贝叶斯或马尔科夫**；
- 连接学派（Connectionists）的研究者相信智能起源于高度互联的简单机制。这种方法的第一个具体形式是出现于1959年的感知器，最新的形式是深度学习。爱用方法：**神经网络**；
- 进化学派（Evolutionists）是应用进化的过程，例如交叉和突变以达到一种初期的智能行为的一派。在深度学习中，GA确实有被用来替代梯度下降法，所以它不是一种孤立的方法。爱用方法：**遗传算法**；
- 类推学派（The analogizers）更多地关注心理学和数学最优化，通过外推来进行相似性判断。类推学派遵循“最近邻”原理进行研究，各种电子商务网站上的产品推荐是类推方法最常见的示例。爱用方法：**支持向量机**；
- 21世纪的头十年，最显著的就是连接学派和符号学派的结合，由此产生了记忆神经网络以及能够根据知识进行简单推理的智能体，基础架构也向大规模云计算转换。第二个十年，连接学派、符号学派和贝叶斯学派也将融合到一起，而主要的局面将是感知任务由神经网络完成，但涉及到推理和行动还是需要人为编写规则；从2040年以后，根据普华永道的预测，主流学派将成为 Algorithmic convergence，也即各种算法融合在一起，届时机器自主学习，也即元学习（Meta-learning）实现，计算服务将无处不在。

#### 机器学习：工作原理及适用场景

- 机器学习能够通过“学习”大量的数据，在不需要人为编程的情况下，生成以及识别特定的对象，比如人脸。目前，机器学习也是商业应用中最常用的算法。
- 机器学习是一类关注从数据中找到模式，并根据这些模式进行预测的研究和算法。机器学习属于人工智能，它与数据挖掘、统计学、模式识别等相关领域的关系如下图所示：

![机器学习和人工智能的关系](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_related_AI.png)

- 机器学习的主要流程步骤：选择数据（训练用数据、验证用数据、测试用数据）、数据建模（使用训练数据构建涉及相关特征的模型）、验证模型（用验证数据验证建立的模型）、调试模型（为了提升模型的性能，使用更多的数据、不同的特征，调整参数，这也是最耗时耗力的一步）、使用模型（部署模型训练好的模型，对新的数据进行预测）、测试模型（使用测试用数据验证模型，并评估模型的性能）；

![机器学习工作原理](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/how_ML_works.png)

#### 实际应用机器学习：什么才是特定任务的正确算法？
机器学习中常用的算法有很多，具体需要用哪种，很大程度上取决于你手头的数据及其特征，你的训练目标，尤其是具体的使用场景。除非特殊情况，不必使用最复杂的算法。下面是常见的机器学习算法。

- 决策树（Decision Trees）：是一个决策支持工具，它使用树形图或决策模型以及序列可能性。包括各种偶然事件的后果、资源成本、功效。从商务决策的角度来看，大部分情况下，决策树是一个人为了评估做出正确决定的概率需要问的是/否问题的最小数值。它能让你以一个结构化和系统化的方式来处理这个问题，然后得出一个合乎逻辑的结论。

![决策树](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_decision_trees.png)

- 支持向量机：是二元分类算法。给定一组两种类型的N维的地方点，SVM产生一个（N - 1）维超平面到这些点分成2组。假设你有两种类型的点，且它们是线性可分的。SVM将找到一条直线将这些点分成2种类型，并且这条直线会尽可能地远离所有的点。在规模上，目前使用SVM（在适当修改的情况下）解决的最大的问题包括显示广告、人类剪接位点识别、基于图像的性别检测和大规模的图像分类等等。

![支持向量机](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_SVM.png)

- 逻辑回归：是一种强大的统计方法，它能建模出一个二项结果与一个（或多个）解释变量。它通过估算使用逻辑运算的概率，测量分类依赖变量和一个（或多个）独立的变量之间的关系，是累积的逻辑分布情况。

![逻辑回归](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_regression.png)

- 朴素贝叶斯分类：是一种十分简单的分类算法，方程P(A|B)是后验概率，P(B|A)是可能性，P(A)是类先验概率，而P(B)是预测先验概率。朴素贝叶斯的思想基础是这样的：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。

![朴素贝叶斯分类](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_native_bayes_classification.png)

- 隐马尔科夫模型通过分析可观察的数据来计算隐藏状态的概率，然后通过分析隐藏状态来估计未来可能观察到的模式。一个例子是，通过分析高气压（或低气压）的概率来预测天气是晴天、雨天或多云的可能性。

![隐马尔科夫模型](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_hidden_markov_models.png)

- 随机森林算法结合了多个树，使用随机挑选的数据子集，以此提升决策树的分析准确率。下图中的例子展示的是与乳腺癌复发相关的不同基因及其几率。随机深林算法的优势在于能够处理大规模数据集，以及大量看似不相关的数据，可以用于风险评估和客户信息分析。

![随机森林](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_random_forest.png)

- 递归神经网络：可以描述动态时间行为，因为和前馈神经网络接受较特定结构的输入不同，RNN将状态在自身网络中循环传递，因此可以接受更广泛的时间序列结构输入。手写识别是最早成功利用RNN的研究结果，其他应用还包括图像分类、图说生成和情感分析。

![递归神经网络](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_RNN.png)

- 长短期记忆和门控循环单元（gated recurrent unit, GRU）神经网络同时具有长期记忆和短期记忆。换句话说，这些较新的 RNN 具有更好的记忆控制，允许先前的值持续保存，或必要时为许多序列步骤重置，避免在步骤到步骤的传递时造成“梯度衰减”（gradient decay）。LSTM 和 GRU 网络通过记忆体组（memory blocks）和被称为“门”（gates）的结构适当地 pass 或 reset 值来实现这种记忆控制。

![长短期记忆](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_LSTM.png)

- 卷积神经网络：是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理、药物发现等有出色表现。卷积神经网络由一个或多个卷积层和顶端的全连通层（对应经典的神经网络）组成，同时也包括关联权重和池化层。这一结构使得卷积神经网络能够利用输入数据的二维结构。与其他深度学习结构相比，卷积神经网络在图像和语音识别方面能够给出更优的结果。这一模型也可以使用反向传播算法进行训练。相比较其他深度、前馈神经网络，卷积神经网络需要估计的参数更少。

![卷积神经网络](http://oi46mo3on.bkt.clouddn.com/18_reading_201704/ML_CNN.png)


### [关于微服务的发展方向，我们和5位专家聊了聊](https://mp.weixin.qq.com/s/F4SLNmCs7iIkZe9nxnXDdA) Mark Little/薛命灯 

- 使用“微服务架构”这个名字会更恰当些。它是一种架构风格，它把一系列协作的服务组织成一个系统来支撑业务。
- 组织的沟通结构与服务架构有着更深层次的关系，这个联系比我们先前意识到的要更加紧密。
- 要做的：监控，监控，监控；做好服务的独立部署；确保你的团队具有DevOps文化；对微服务架构的实施进行评审，并把它作为指南；让微服务仪表化、可调试，并提供度量指标，把测试作为一等公民；对容器部署技术进行评估，容器技术有很大优势。


### [kafka数据可靠性深度解读](https://mp.weixin.qq.com/s/ExzSzf0ue7d-_Qv8q6p9bw) 朱忠华



### [去哪儿网机票搜索系统的高并发架构设计](https://mp.weixin.qq.com/s/1ipdByfsaTcHpo_W5gJVug) 蒋志伟



### [聊聊分布式定时任务中间件架构及其实现](https://mp.weixin.qq.com/s/pqOujhOQlxw6XR_e7MP02w) 张亮



### [2017年会是Serverless爆发之年吗？](https://mp.weixin.qq.com/s/vQ22_disiOIbfOHz95Ls-w) 麦克周



### [Java 9新特性介绍及Jigsaw一览](http://2017.qconbeijing.com/) QCON/杨晓峰



### [打造高性能高可用的搜索服务——爱奇艺搜索架构实践](http://2017.qconbeijing.com/) QCON/陈爱云


### [高速发展业务的架构应对实践](http://2017.qconbeijing.com/) QCON/陈霖


### [美团点评旅游推荐系统的演进](http://2017.qconbeijing.com/) QCON/郑刚


### [深度学习在电子商务中的应用](http://2017.qconbeijing.com/) QCON/程进兴


### [微信红包后台系统可用性设计实践](http://2017.qconbeijing.com/) QCON/michaelfang


### [异步场景下的全栈溯源](http://2017.qconbeijing.com/) QCON/杨金全


### [异构系统链路追踪——滴滴 trace 实践](http://2017.qconbeijing.com/) QCON




### [任何人都能看懂的TensorFlow介绍](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650718466&idx=1&sn=016f111001e8354d49dd4ce279d283cd) Soon Hin Khor/机器之心


### [小白也能看懂的TensorFlow介绍](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650723520&idx=1&sn=d204284574e9e56682b6ed6f9dcaff01) Soon Hin Khor/机器之心


### [Leaf——美团点评分布式ID生成系统](http://tech.meituan.com/MT_Leaf.html) 照东


### [DevOps详解](http://www.infoq.com/cn/articles/detail-analysis-of-devops)  Jerome Kehrli/大愚若智



### [在Elasticsearch中应用机器学习排序LTR](http://www.infoq.com/cn/articles/we-are-bringing-learning-to-rank-to-elasticsearch)  OpenSource Connections/杨振涛



### [LTR在个性化电商搜索领域的应用](http://www.infoq.com/cn/presentations/learning-to-rank-in-the-field-of-personalized-electric-business-search)  吴晨



**免责声明：相关链接版本为原作者所有，如有侵权，请告知删除。**

**随手记系列：**
- [阅读随手记 201703](http://ginobefunny.com/post/reading_record_201703/)
- [阅读随手记 201702](http://ginobefunny.com/post/reading_record_201702/)
- [阅读随手记 201701](http://ginobefunny.com/post/reading_record_201701/)
- [阅读随手记 201612](http://ginobefunny.com/post/reading_record_201612/)
